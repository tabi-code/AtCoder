{
	"solve": {
		"prefix": "solve",
		"body": [
		  "import sys",
		  "import math",
		  "import collections",
		  "import itertools",
		  "import bisect",
		  "import heapq",
		  "import fractions",
		  "from operator import mul",
		  "from functools import reduce",
		  "from functools import lru_cache",
		  "",
		  "",
		  "def solve():",
		  "    input = sys.stdin.readline",
		  "    mod = 10 ** 9 + 7",
		  "    $1",
		  "",
		  "",
		  "if __name__ == '__main__':",
		  "    solve()",
		  ""
		],
		"description": "solve"
	  },
	  "for_in": {
		"prefix": "for_in",
		"body": [
		  "for $1 in $2:"
		],
		"description": "for_in"
	  },
	  "int_input": {
		"prefix": "int_input",
		"body": [
		  "$1 = int(input().rstrip('\\n'))"
		],
		"description": "int_input"
	  },
	  "int_input_for": {
		"prefix": "int_input_for",
		"body": [
		  "$1 = [int(input().rstrip('\\n')) for _ in range($2)]"
		],
		"description": "int_input_for"
	  },
	  "str_input": {
		"prefix": "str_input",
		"body": [
		  "$1 = $2str(input().rstrip('\\n'))$3"
		],
		"description": "str_input"
	  },
	  "for_in_range": {
		"prefix": "for_in_range",
		"body": [
		  "for $1 in range($2):"
		],
		"description": "for_in_range"
	  },
	  "str_input_for": {
		"prefix": "str_input_for",
		"body": [
		  "$1 = [$2str(input().rstrip('\\n'))$3 for _ in range($4)]"
		],
		"description": "str_input_for"
	  },
	  "list_map_str_input": {
		"prefix": "list_map_str_input",
		"body": [
		  "$1 = list(map(str, str(input().rstrip('\\n')).split()))"
		],
		"description": "list_map_str_input"
	  },
	  "list_map_int_input": {
		"prefix": "list_map_int_input",
		"body": [
		  "$1 = list(map(int, input().rstrip('\\n').split()))"
		],
		"description": "list_map_int_input"
	  },
	  "alg_segment_tree": {
		"prefix": "alg_segment_tree",
		"body": [
		  "class SegmentTree:",
		  "    def __init__(self, size, f=lambda x, y: x + y, default=0):",
		  "        self.size = 2 ** (size - 1).bit_length()",
		  "        self.default = default",
		  "        self.dat = [default] * (self.size * 2)",
		  "        self.f = f",
		  "",
		  "    def update(self, i, x):",
		  "        i += self.size",
		  "        self.dat[i] = x",
		  "        while i > 0:",
		  "            i >>= 1",
		  "            self.dat[i] = self.f(self.dat[i * 2], self.dat[i * 2 + 1])",
		  "",
		  "    def query(self, left, right):",
		  "        left += self.size",
		  "        right += self.size",
		  "        left_res, right_res = self.default, self.default",
		  "        while left < right:",
		  "            if left & 1:",
		  "                left_res = self.f(left_res, self.dat[left])",
		  "                left += 1",
		  "",
		  "            if right & 1:",
		  "                right -= 1",
		  "                right_res = self.f(self.dat[right], right_res)",
		  "            left >>= 1",
		  "            right >>= 1",
		  "        res = self.f(left_res, right_res)",
		  "        return res"
		],
		"description": "alg_segment_tree"
	  },
	  "alg_union_find": {
		"prefix": "alg_union_find",
		"body": [
		  "class UnionFind():",
		  "    def __init__(self, n):",
		  "        self.n = n",
		  "        self.parents = [-1] * n",
		  "",
		  "    def find(self, x):",
		  "        if self.parents[x] < 0:",
		  "            return x",
		  "        else:",
		  "            self.parents[x] = self.find(self.parents[x])",
		  "            return self.parents[x]",
		  "",
		  "    def union(self, x, y):",
		  "        x = self.find(x)",
		  "        y = self.find(y)",
		  "",
		  "        if x == y:",
		  "            return",
		  "",
		  "        if self.parents[x] > self.parents[y]:",
		  "            x, y = y, x",
		  "",
		  "        self.parents[x] += self.parents[y]",
		  "        self.parents[y] = x",
		  "",
		  "    def size(self, x):",
		  "        return -self.parents[self.find(x)]",
		  "",
		  "    def same(self, x, y):",
		  "        return self.find(x) == self.find(y)",
		  "",
		  "    def members(self, x):",
		  "        root = self.find(x)",
		  "        return [i for i in range(self.n) if self.find(i) == root]",
		  "",
		  "    def roots(self):",
		  "        return [i for i, x in enumerate(self.parents) if x < 0]",
		  "",
		  "    def group_count(self):",
		  "        return len(self.roots())",
		  "",
		  "    def all_group_members(self):",
		  "        return {r: self.members(r) for r in self.roots()}",
		  "",
		  "    def __str__(self):",
		  "        return '\\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())"
		],
		"description": "alg_union_find"
	  },
	  "alg_permutation": {
		"prefix": "alg_permutation",
		"body": [
		  "def permutation(n, r):",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i)",
		  "        return denominator // 1",
		  ""
		],
		"description": "alg_permutation"
	  },
	  "alg_permutation_mod": {
		"prefix": "alg_permutation_mod",
		"body": [
		  "def permutation_mod(n, r, mod):",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i) % mod",
		  "        return denominator // 1",
		  ""
		],
		"description": "alg_permutation_mod"
	  },
	  "alg_memoization_recursion": {
		"prefix": "alg_memoization_recursion",
		"body": [
		  "@lru_cache(maxsize=None)",
		  "def memo_func():"
		],
		"description": "alg_memoization_recursion"
	  },
	  "alg_factorial": {
		"prefix": "alg_factorial",
		"body": [
		  "def factorial(denominator_no):",
		  "    return math.factorial(denominator_no)"
		],
		"description": "alg_factorial"
	  },
	  "alg_factorial_mod": {
		"prefix": "alg_factorial_mod",
		"body": [
		  "def factorial_mod(denominator_no, molecule_list, mod):",
		  "    denominator = 1",
		  "    for i in range(1, denominator_no + 1):",
		  "        denominator = (denominator * i) % mod",
		  "    molecule = 1",
		  "    for molecule_no in molecule_list:",
		  "        for i in range(1, molecule_no + 1):",
		  "            molecule = (molecule * i) % mod",
		  "    return denominator * pow(molecule, mod - 2, mod) % mod",
		  ""
		],
		"description": "alg_factorial_mod"
	  },
	  "alg_combination_mod": {
		"prefix": "alg_combination_mod",
		"body": [
		  "def combination_mod(n, r, mod):",
		  "    r = min(n - r, r)",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i) % mod",
		  "        molecule = 1",
		  "        for i in range(1, r + 1):",
		  "            molecule = (molecule * i) % mod",
		  "        return denominator * pow(molecule, mod - 2, mod) % mod",
		  ""
		],
		"description": "combination_mod"
	  },
	  "alg_combination": {
		"prefix": "alg_combination",
		"body": [
		  "def combination(n, r):",
		  "    r = min(n - r, r)",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i)",
		  "        molecule = 1",
		  "        for i in range(1, r + 1):",
		  "            molecule = (molecule * i)",
		  "        return denominator // molecule",
		  ""
		],
		"description": "alg_combination"
	  },
	  "alg_duplicate_combination_mod": {
		"prefix": "alg_duplicate_combination_mod",
		"body": [
		  "def duplicate_combination_mod(n, r, mod):",
		  "    n = n + r - 1",
		  "    r = min(n - r, r)",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i) % mod",
		  "        molecule = 1",
		  "        for i in range(1, r + 1):",
		  "            molecule = (molecule * i) % mod",
		  "        return denominator * pow(molecule, mod - 2, mod) % mod",
		  ""
		],
		"description": "alg_duplicate_combination_mod"
	  },
	  "alg_duplicate_combination": {
		"prefix": "alg_duplicate_combination",
		"body": [
		  "def duplicate_combination(n, r):",
		  "    n = n + r - 1",
		  "    r = min(n - r, r)",
		  "    if r == 0:",
		  "        return 1",
		  "    else:",
		  "        denominator = 1",
		  "        for i in range(n, n - r, -1):",
		  "            denominator = (denominator * i)",
		  "        molecule = 1",
		  "        for i in range(1, r + 1):",
		  "            molecule = (molecule * i)",
		  "        return denominator // molecule",
		  ""
		],
		"description": "alg_duplicate_combination"
	  },
	  "alg_lca": {
		"prefix": "alg_lca",
		"body": [
		  "",
		  "class Lca(object):",
		  "    def __init__(self, graph, root=0):",
		  "        self.graph = graph",
		  "        self.root = root",
		  "        self.n = len(graph)",
		  "        self.bit_len = (self.n - 1).bit_length()",
		  "        self.depth = [-1 if i != root else 0 for i in range(self.n)]",
		  "        self.parent = [[-1] * self.n for _ in range(self.bit_len)]",
		  "        self.bfs()",
		  "        self.doubling()",
		  "",
		  "    def bfs(self):",
		  "        ql = [[0, self.root]]",
		  "        ql = collections.deque(ql)",
		  "        fq = collections.defaultdict(list)",
		  "        fq[self.root] = 0",
		  "        while True:",
		  "            if len(ql) != 0:",
		  "                cost, tmp = ql.popleft()",
		  "                for tmv in self.graph[tmp]:",
		  "                    if tmv not in fq:",
		  "                        ql.append([cost + 1, tmv])",
		  "                        fq[tmv] = cost + 1",
		  "            else:",
		  "                break",
		  "",
		  "    def doubling(self):",
		  "        for i in range(1, self.bit_len):",
		  "            for v in range(self.n):",
		  "                if self.parent[i - 1][v] != -1:",
		  "                    self.parent[i][v] = self.parent[i - 1][self.parent[i - 1][v]]",
		  "",
		  "    def get(self, u, v):",
		  "        if self.depth[v] < self.depth[u]:",
		  "            u, v = v, u",
		  "        du = self.depth[u]",
		  "        dv = self.depth[v]",
		  "",
		  "        for i in range(self.bit_len):",
		  "            if (dv - du) >> i & 1:",
		  "                v = self.parent[i][v]",
		  "        if u == v:",
		  "            return u",
		  "",
		  "        for i in range(self.bit_len - 1, -1, -1):",
		  "            pu, pv = self.parent[i][u], self.parent[i][v]",
		  "            if pu != pv:",
		  "                u, v = pu, pv",
		  "        return self.parent[0][u]"
		],
		"description": "alg_lca"
	  },
	  "alg_warsal_floyd": {
		"prefix": "alg_warsal_floyd",
		"body": [
		  "wn = list(map(int, input().rstrip('\\n').split()))",
		  "inf = 10 ** 13",
		  "wl = [[inf] * wn for _ in range(wn)]",
		  "for i in range(wn):",
		  "    wl[i][i] = 0",
		  "",
		  "for i in range(wn):",
		  "    wa, wb, wc = list(map(int, input().rstrip('\\n').split()))",
		  "    wl[wa - 1][wb - 1] = wc",
		  "    wl[wb - 1][wa - 1] = wc",
		  "",
		  "for i in range(wn):",
		  "    for j in range(wn):",
		  "        for k in range(wn):",
		  "            wl[j][k] = min(wl[j][k], wl[j][i] + wl[i][k])",
		  "$1"
		],
		"description": "alg_warsal_floyd"
	  },
	  "alg_z_algorithm": {
		"prefix": "alg_z_algorithm",
		"body": [
		  "st = $1",
		  "st_len = len(st)",
		  "z_algorithm = [0] * st_len",
		  "z_i = 1",
		  "z_j = 0",
		  "while z_i < st_len:",
		  "    while z_i + z_j < st_len and st[z_j] == st[z_i + z_j]:",
		  "        z_j += 1",
		  "    z_algorithm[z_i] = z_j",
		  "    if z_j == 0:",
		  "        z_i += 1",
		  "        continue",
		  "    z_k = 1",
		  "    while z_i + z_k < st_len and z_k + z_algorithm[z_k] < z_j:",
		  "        z_algorithm[z_i + z_k] = z_algorithm[z_k]",
		  "        z_k += 1",
		  "    z_i += z_k",
		  "    z_j -= z_k",
		  "print(z_algorithm)",
		  ""
		],
		"description": "alg_z_algorithm"
	  },
	  "alg_bfs_tree": {
		"prefix": "alg_bfs_tree",
		"body": [
		  "mpl = collections.defaultdict(list)",
		  "for i in range($1):",
		  "    mpa, mpb = list(map(int, input().rstrip('\\n').split()))",
		  "    mpl[mpa-1] += [mpb-1]",
		  "    mpl[mpb-1] += [mpa-1]",
		  "    ",
		  "ql = [[0, $2]]",
		  "ql = collections.deque(ql)",
		  "fq = collections.defaultdict(list)",
		  "fq[$3]",
		  "while True:",
		  "    if len(ql) != 0:",
		  "        cost, tmp = ql.popleft()",
		  "        for tmv in tmd[tmp]:",
		  "            if tmv not in fq:",
		  "                ql.append([cost + 1, tmv])",
		  "                fq[tmv]",
		  "    else:",
		  "        break"
		],
		"description": "alg_bfs_tree"
	  },
	  "alg_bfs_grid": {
		"prefix": "alg_bfs_grid",
		"body": [
		  "ql = [[0, $1]]",
		  "ql = collections.deque(ql)",
		  "fq = collections.defaultdict(list)",
		  "fq[$1]",
		  "while True:",
		  "    if len(ql) != 0:",
		  "        cost, yv, xv = ql.popleft()",
		  "        for yv, xv in [[yv + 1, xv], [yv - 1, xv], [yv, xv + 1], [yv, xv - 1]]:",
		  "            if 0 <= yv < h and 0 <= xv < w:",
		  "                if (yv, xv) not in fq:",
		  "                    ql.append([cost + 1, yv, xv])",
		  "                    fq[yv, xv]",
		  "    else:",
		  "        break"
		],
		"description": "alg_bfs_grid"
	  },
	  "alg_segment_tree_range_add": {
		"prefix": "alg_segment_tree_range_add",
		"body": [
		  "class SegmentTreeRangeAdd:",
		  "    def __init__(self, size, f=lambda x, y: min(x, y), default=2 ** 31 - 1):",
		  "        self.size = (size - 1).bit_length()",
		  "        self.no = 2 ** self.size",
		  "        self.default = default",
		  "        self.data = [default] * (self.no * 2)",
		  "        self.lazy = [None] * (self.no * 2)",
		  "        self.f = f",
		  "",
		  "    def get_index(self, left, right):",
		  "        l_left = (left + self.no) >> 1",
		  "        r_right = (right + self.no) >> 1",
		  "        lc = 0 if left & 1 else (l_left & -l_left).bit_length()",
		  "        rc = 0 if right & 1 else (r_right & -r_right).bit_length()",
		  "        for i in range(self.size):",
		  "            if rc <= i:",
		  "                yield r_right",
		  "            if l_left < r_right and lc <= i:",
		  "                yield l_left",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "",
		  "    def propagates(self, *ids):",
		  "        for i in reversed(ids):",
		  "            v = self.lazy[i - 1]",
		  "            if v is None:",
		  "                continue",
		  "            self.lazy[2 * i - 1] += v",
		  "            self.data[2 * i - 1] += v",
		  "            self.lazy[2 * i] += v",
		  "            self.data[2 * i] += v",
		  "            self.lazy[i - 1] = 0",
		  "",
		  "    def update(self, left, right, x):",
		  "        *ids, = self.get_index(left, right)",
		  "        self.propagates(*ids)",
		  "        l_left = self.no + left",
		  "        r_right = self.no + right",
		  "        while l_left < r_right:",
		  "            if r_right & 1:",
		  "                r_right -= 1",
		  "                self.lazy[r_right - 1] += x",
		  "                self.data[r_right - 1] += x",
		  "            if l_left & 1:",
		  "                self.lazy[l_left - 1] += x",
		  "                self.data[l_left - 1] += x",
		  "                l_left += 1",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "        for i in ids:",
		  "            self.data[i - 1] = self.f(self.data[2 * i - 1], self.data[2 * i])",
		  "",
		  "    def query(self, left, right):",
		  "        self.propagates(*self.get_index(left, right))",
		  "        l_left = self.no + left",
		  "        r_right = self.no + right",
		  "",
		  "        res = self.default",
		  "        while l_left < r_right:",
		  "            if r_right & 1:",
		  "                r_right -= 1",
		  "                res = self.f(res, self.data[r_right - 1])",
		  "            if l_left & 1:",
		  "                res = self.f(res, self.data[l_left - 1])",
		  "                l_left += 1",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "        return res"
		],
		"description": "alg_segment_tree_range_add"
	  },
	  "alg_segment_tree_range_update": {
		"prefix": "alg_segment_tree_range_update",
		"body": [
		  "class AlgSegmentTreeRangeUpdate:",
		  "    def __init__(self, size, f=lambda x, y: min(x, y), default=2 ** 31 - 1):",
		  "        self.size = (size - 1).bit_length()",
		  "        self.no = 2 ** self.size",
		  "        self.default = default",
		  "        self.data = [default] * (self.no * 2)",
		  "        self.lazy = [None] * (self.no * 2)",
		  "        self.f = f",
		  "",
		  "    def get_index(self, left, right):",
		  "        l_left = (left + self.no) >> 1",
		  "        r_right = (right + self.no) >> 1",
		  "        lc = 0 if left & 1 else (l_left & -l_left).bit_length()",
		  "        rc = 0 if right & 1 else (r_right & -r_right).bit_length()",
		  "        for i in range(self.size):",
		  "            if rc <= i:",
		  "                yield r_right",
		  "            if l_left < r_right and lc <= i:",
		  "                yield l_left",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "",
		  "    def propagates(self, *ids):",
		  "        for i in reversed(ids):",
		  "            v = self.lazy[i - 1]",
		  "            if v is None:",
		  "                continue",
		  "            self.lazy[2 * i - 1] = v",
		  "            self.data[2 * i - 1] = v",
		  "            self.lazy[2 * i] = v",
		  "            self.data[2 * i] = v",
		  "            self.lazy[i - 1] = None",
		  "",
		  "    def update(self, left, right, x):",
		  "        *ids, = self.get_index(left, right)",
		  "        self.propagates(*ids)",
		  "        l_left = self.no + left",
		  "        r_right = self.no + right",
		  "        while l_left < r_right:",
		  "            if r_right & 1:",
		  "                r_right -= 1",
		  "                self.lazy[r_right - 1] = x",
		  "                self.data[r_right - 1] = x",
		  "            if l_left & 1:",
		  "                self.lazy[l_left - 1] = x",
		  "                self.data[l_left - 1] = x",
		  "                l_left += 1",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "        for i in ids:",
		  "            self.data[i - 1] = self.f(self.data[2 * i - 1], self.data[2 * i])",
		  "",
		  "    def query(self, left, right):",
		  "        self.propagates(*self.get_index(left, right))",
		  "        l_left = self.no + left",
		  "        r_right = self.no + r",
		  "",
		  "        res = self.default",
		  "        while l_left < r_right:",
		  "            if r_right & 1:",
		  "                r_right -= 1",
		  "                res = self.f(res, self.data[r_right - 1])",
		  "            if l_left & 1:",
		  "                res = self.f(res, self.data[l_left - 1])",
		  "                l_left += 1",
		  "            l_left >>= 1",
		  "            r_right >>= 1",
		  "        return res"
		],
		"description": "alg_segment_tree_range_update"
	  },
	  "alg_binary_search": {
		"prefix": "alg_binary_search",
		"body": [
		  "cor_v = 10 ** 20",
		  "inc_v = -1",
		  "while cor_v - inc_v > 1:",
		  "    bin_v = (cor_v + inc_v) // 2",
		  "    cost = 0",
		  "    #条件を満たすcostを全検索",
		  "",
		  "    #costが制約を満たすか",
		  "    if cost <= bin_v:",
		  "        cor_v = bin_v",
		  "    else:",
		  "        inc_v = bin_v",
		  "print(cor_v)",
		  ""
		],
		"description": "alg_binary_search"
	  }
}